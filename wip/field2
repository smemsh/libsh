return
#
# Takes a range specifier and returns the content of all the
# requested field numbers.  Optional input and output delimiters.
#
# Syntax: one of these three forms:
#
# 	indelim outdelim range
# 	indelim range
# 	range
#
# Usage then becomes like so:
#
# 	field r ({in,out}delim=whitespace, rangeset=r)
# 	field id r (indelim=id, outdelim=whitespace, rangeset=r)
# 	field id od r (indelim=id, outdelim=od, rangeset=r)
#
# XXX TODO allow to specify od but not id
#
# Where unspecified, a delim defaults to a space or tab.
# This is currently the only way to use more than one
# character as a delimiter, since the code only handles
# specifying single character delimiters right now.
# XXX TODO huh? contradictory
#
# Range specifier is a comma separated list of ranges, where
# ranges are either single numbers or first-last contiguous
# sequences, so for example:
#
# 	1-3,4,8,7-10
#
# would return fields "1 2 3 4 8 7 8 9 10" to the caller.
# unspecified Y in X-Y will default to highest Y in the input
#
# - XXX TODO BUG eats whitespace "dothis '1 2'" == "dothis '1   2'"
# - XXX TODO does it eat backslashes?
# - XXX TODO allow multiple delimiters
# - XXX TODO allow regexes for delimiters
#
# XXX TODO: 10x faster!!!
#
#	awk '{
#		for (i = start; i <= end; i++)
#			printf("%s ", $i);
#		printf("\n");
#	}'
#
#

require range_to_list

field ()
{
	local \
		rangearg \
		indelim \
		outdelim

	case $# in
	(3) indelim="$1" outdelim="$2" rangearg="$3" ;;
	(2) indelim="$1" outdelim=' '  rangearg="$2" ;;
	(1) indelim=' '  outdelim=' '  rangearg="$1" ;;
	(*) return 10;;
	esac

	# we only handle single-character delimiters right now
	#
	((${#indelim} == 1)) || return 20
	((${#outdelim} == 1)) || return 30

	# expands the special-syntax list of ranges into a
	# single list of numbers occupying that range
	#
	# - split up the input into fields as delimited by
	#   the given delimiter, or just sameline whitespace
	#   if none was given
	#
	# - only echo the particular fields that were
	#   requested with the range argument
	#
	# - separate output fields with the specified output
	#   delimiter, which defaults to a space
	#
	local -i fieldnum iterations
	local -a fields
	local -a outarray

	awk "
	BEGIN {
		FS=\"$indelim\"
		OFS=\"$outdelim\"
	}

		fields=($(range_to_list $rangearg ${#line[@]}))
		iterations=${#fields[@]}

		for ((i = 0; i < iterations; i++))
		do
			fieldnum=$((${fields[i]} - 1))
			outarray+=("${line[fieldnum]}")
		done

		(IFS="$outdelim"; echo "${outarray[*]}")
	); done
}
